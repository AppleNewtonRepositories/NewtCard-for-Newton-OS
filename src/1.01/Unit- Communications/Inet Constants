// Constants for using the Newton Internet Enabler// Copyright (c) 1994-1995 Apple Computer, Inc.  All rights reserved.// Transport service type constantsconstant kTCP := 1;constant kUDP := 2;// Utility functions for Internet applicationsDefConst('kNumtoHostAddr,func(addr)begin	// This is the inverse of HostAddrToNum	// It converts a 4 byte array to a "w.x.y.z" string.	local index, str := "";	// A sanity check	if Length(addr) <> 4 then begin		return nil;	end;	for index := 0 to Length(addr) - 1 do begin		str := str & NumberStr(addr[index]);		if index < Length(addr) - 1 then			str := str & ".";	end;	return str;end);DefConst('kHostAddrToNum,func(str)begin	// This is the inverse of NumToHostAddr	// It converts a "w.x.y.z" string to a 4 byte array.	// Actually the separators between the numbers can be any non-digits, except space	local index := 0, partCnt := 0;	local subNum := 0, digits := "0123456789 ";	local num := [0,0,0,0], processNum;	for index := 0 to StrLen(str) - 1 do begin		ch := StrPos(digits, SubStr(str, index, 1), 0);		if not ch then begin			// If first character is not a digit then skip junk at beginning			if index = 0 then processNum := nil;			// Not a digit.  Process number, unless skipping junk			if processNum then begin				// Truncate numbers greater than 255				if subNum > 255 then subNum := 255;				if partCnt < 4 then					num[partCnt] := subNum;				partCnt := partCnt + 1;				subNum := 0;				processNum := nil;			end;		end else begin			// Add the next digit to subNum (unless it was a space)			if ch < 10 then				subNum := subNum * 10 + ch;			processNum := true;		end;	end;	// Truncate numbers greater than 255	if subNum > 255 then subNum := 255;	// Do the last part (which usually won't have a trailing .)	if subNum <> 0 and partCnt < 4 then		num[partCnt] := subNum;	return num;end);DefConst('kIsIPAddr,func(str)begin	// This returns true if the string is an IP address (as opposed to a domain name)	// cheap test now just tests if the string ends with a numeric character	local digits := "0123456789";	local len := strLen(str);	if len > 0 and  StrPos(digits, SubStr(str, len - 1, 1), 0) then		true	else 		nil;end);DefConst('kPortAddrStruct, [		'struct,		['array,'byte,4],		'short	]);	DefConst('kPortAddrData,{	arglist:		[		[0,0,0,0],		0,	// destination port number						],	typelist: kPortAddrStruct,});// Use this to get Instantiate options// protocol must be kSLIP or kPPPDefConst('kGetEndpointConfigOptions, func(linkID,protocol) 	return [		{				label:	"inet",			type:		'service,			opCode:	opSetRequired,			result:	nil,			},		{				label:	"ilid",			// set the link id			type:		'option,			opCode:	opSetRequired,			result:	nil,			form:		'template,			data:				{				arglist:					[					linkID				],				typelist:				[					'struct,					'ulong				],				},		},		{				label:	"itsv",			// set the transport protocol (TCP or UCP)			type:		'option,			opCode:	opSetRequired,			result:	nil,			form:		'template,			data:				{				arglist:					[					protocol					],				typelist:				[					'struct,					'ulong				],				},		},	]);DefConst('kUDPReceiveOptions,	[				{				label:	"iuds",			// get the UDP destination socket			type:		'option,			opCode:	opGetCurrent,			result:	nil,			form:		'template,			data: 	kPortAddrData,			},		{				label:	"iuss",			// get the UDP source socket			type:		'option,			opCode:	opGetCurrent,			result:	nil,			form:		'template,			data:		kPortAddrData,		},	]);		DefConst('kINetBindOptions,func(localPort,useDefaultPort) begin		return [			{					label: "ilpt",				// set the local port				type: 'option,				opCode: opSetRequired,				result: nil,				form: 'template,				data:					{					arglist:						[						localPort,			// local port number						useDefaultPort	// use default port														],					typelist:					[						'struct,						'short,						'boolean					],					},			},		];end);DefConst('kTCPConnectOptions, func(remoteAddr,remotePort) begin			return [				{						label:	"itrs",			// set the TCP remote socket					type:		'option,					opCode:	opSetRequired,					result:	nil,					form:		'template,					data:						{						arglist:							[							remoteAddr,							remotePort,		// remote port number																],						typelist: kPortAddrStruct,					},				},			];	end);			DefConst('kTCPListenOptions,			[				{						label:	"itrs",			// get the TCP remote socket					type:		'option,					opCode:	opGetCurrent,					result:	nil,					form:		'template,					data:	kPortAddrData,				},			];	);			DefConst('kGetIPAddressesOptions,	[{         type    : 'option,         label   : "iprf",         opCode: opGetCurrent,         data    : {                  arglist: [                  		[0,0,0,0],                  		[0,0,0,0],                   ],                   typelist: [                   		'struct,                   		['array,'byte,4],                   		['array,'byte,4],                   ]           }     }]);		DefConst('kUDPPutBytesOptions,func(addr,port) begin		return	[{					label:	"iuds",			// set the UDP destination socket				type:		'option,				opCode:	opSetRequired,				result:	nil,				form:		'template,				data:					{					arglist:						[						addr,						port,		// remote port number														],					typelist: kPortAddrStruct,				},			}];	end);		