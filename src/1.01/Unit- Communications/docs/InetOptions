// Utility functions for Internet applications// Copyright (c) 1994-1995 Apple Computer, Inc.  All rights reserved.DefConst('kNumtoHostAddr,func(addr)begin	// This is the inverse of HostAddrToNum	// It converts a 4 byte array to a "w.x.y.z" string.	local index, str := "";	// A sanity check	if Length(addr) <> 4 then begin		Print("Array does not have 4 elements");		return "O.O.P.S";	end;	for index := 0 to Length(addr) - 1 do begin		str := str & NumberStr(addr[index]);		if index < Length(addr) - 1 then			str := str & ".";	end;	//if debugon then	//	Print("NumToHostAddr returning " && str);	return str;end);DefConst('kHostAddrToNum,func(str)begin	// This is the inverse of NumToHostAddr	// It converts a "w.x.y.z" string to a 4 byte array.	// Actually the separators between the numbers can be any non-digits, except space	local index := 0, partCnt := 0;	local subNum := 0, digits := "0123456789 ";	local num := [0,0,0,0], processNum;	for index := 0 to StrLen(str) - 1 do begin		ch := StrPos(digits, SubStr(str, index, 1), 0);		if not ch then begin			// If first character is not a digit then skip junk at beginning			if index = 0 then processNum := nil;			// Not a digit.  Process number, unless skipping junk			if processNum then begin				// Truncate numbers greater than 255				if subNum > 255 then subNum := 255;				if partCnt < 4 then					num[partCnt] := subNum;				partCnt := partCnt + 1;				subNum := 0;				processNum := nil;			end;		end else begin			// Add the next digit to subNum (unless it was a space)			if ch < 10 then				subNum := subNum * 10 + ch;			processNum := true;		end;	end;	// Truncate numbers greater than 255	if subNum > 255 then subNum := 255;	// Do the last part (which usually won't have a trailing .)	if subNum <> 0 and partCnt < 4 then		num[partCnt] := subNum;	//if debugon then	//	Print("HostAddrToNum returning " && num);	return num;end);DefConst('kIsIPAddr,func(str)begin	// This returns true if the string is an IP address (as opposed to a domain name)	// cheap test now just tests if the string ends with a numeric character	local digits := "0123456789";	local len := strLen(str);	if len > 0 and  StrPos(digits, SubStr(str, len - 1, 1), 0) then		true	else 		nil;end);DefConst('kPortAddrStruct, [		'struct,		'byte,		'byte,		'byte,		'byte,		'short	]);	DefConst('kPortAddrData,{	arglist:		[		0,	// destination host addr - byte 1		0,	// destination host addr - byte 2		0,	// destination host addr - byte 3		0,	// destination host addr - byte 4		0,	// destination port number						],	typelist: kPortAddrStruct,});DefConst('kGetEndpointConfigOptions, func(linkID,protocol) 	return [		{				label:	"inet",			type:		'service,			opCode:	opSetRequired,			result:	nil,			},		{				label:	"ilid",			// set the link id			type:		'option,			opCode:	opSetRequired,			result:	nil,			form:		'template,			data:				{				arglist:					[					linkID				],				typelist:				[					'struct,					'ulong				],				},		},		{				label:	"itsv",			// set the transport protocol (TCP or UCP)			type:		'option,			opCode:	opSetRequired,			result:	nil,			form:		'template,			data:				{				arglist:					[					protocol + 1					],				typelist:				[					'struct,					'ulong				],				},		},	]);DefConst('kUDPReceiveOptions,	[		//		{	//			label:	"iuds",			// set the UDP destination socket//			type:		'option,//			opCode:	opGetCurrent,//			result:	nil,//			form:		'template,//			data: 	kPortAddrData,	//		},		{				label:	"iuss",			// get the UDP source socket			type:		'option,			opCode:	opGetCurrent,			result:	nil,			form:		'template,			data:		kPortAddrData,		},	]);		DefConst('kINetBindOptions,func(localPort,useDefaultPort) begin		return [			{					label: "ilpt",				// set the local port				type: 'option,				opCode: opSetRequired,				result: nil,				form: 'template,				data:					{					arglist:						[						localPort,			// local port number						useDefaultPort	// use default port														],					typelist:					[						'struct,						'short,						'boolean					],					},			},		];end);DefConst('kTCPConnectOptions, func(remoteAddr,remotePort) begin			return [				{						label:	"itrs",			// set the TCP remote socket					type:		'option,					opCode:	opSetRequired,					result:	nil,					form:		'template,					data:						{						arglist:							[							remoteAddr[0],	// remote host addr - byte 1							remoteAddr[1],	// remote host addr - byte 2							remoteAddr[2],	// remote host addr - byte 3							remoteAddr[3],	// remote host addr - byte 4							remotePort,		// remote port number																],						typelist: kPortAddrStruct,					},				},			];	end);			DefConst('kTCPListenOptions,			[				{						label:	"itrs",			// get the TCP remote socket					type:		'option,					opCode:	opGetCurrent,					result:	nil,					form:		'template,					data:	kPortAddrData,				},			];	);			DefConst('kUDPPutBytesOptions,func(addr,port) begin		return	[{					label:	"iuds",			// set the UDP destination socket				type:		'option,				opCode:	opSetRequired,				result:	nil,				form:		'template,				data:					{					arglist:						[						addr[0],	// remote host addr - byte 1						addr[1],	// remote host addr - byte 2						addr[2],	// remote host addr - byte 3						addr[3],	// remote host addr - byte 4						port,		// remote port number														],					typelist: kPortAddrStruct,				},			}];	end);		 constant kInetErrStreamInoperative  := -60053;  DefConst('protoCommCallback, {	async: TRUE,	callbacksym : 'NoProtoCommCallbackSym,	completionScript: func(ep, options, err)	begin		Perform(ep,callbacksym,[options,err])	end,	reqTimeout: 2*60000, // timeout after 2 minutes});    